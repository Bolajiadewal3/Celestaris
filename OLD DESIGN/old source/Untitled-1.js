
/*

  const { gl } = useThree();
  useEffect(() => {
    gl.shadowMap.enabled = true;
    gl.shadowMap.type = THREE.PCFSoftShadowMap; 
    console.log("TESTING")
    console.log(gl.shadowMap.type)// Use soft shadows
  }, [gl]);







  const { scene } = useGLTF('bedroom.glb')

  const { nodes, materials } = useGLTF('bedroom.glb')







  console.dir(scene);
  console.dir(nodes["Computer"]);
  const computerScreen = nodes["Computer"] // Replace with the actual node name for the screen



  // Function to traverse the scene and enable shadows
  const enableShadows = (object) => {
    if (object.isMesh) {
      console.log("SHADOWED")
      object.castShadow = true;  // Enable shadow casting
      object.receiveShadow = true;  // Enable receiving shadows
    }
    
    // Recursively traverse all child objects
    if (object.children) {
      object.children.forEach(child => enableShadows(child))
    }
  }

  useEffect(() => {
    // When the model is loaded, traverse it and enable shadows
    if (scene) {
      enableShadows(scene)
    }
  }, [scene])



  const [screenPosition, setScreenPosition] = useState(new THREE.Vector3())
  const [iframePosition, setIframePosition] = useState(new THREE.Vector3())  // Store the iframe's fixed position


  const cameraRef = useRef()
  const [hasZoomed, setHasZoomed] = useState(false) // Track if zooming has already happened
/*

  useEffect(() => {
    if (!hasZoomed) {
      const timeout = setTimeout(() => {
        props.setZooming(true)
        console.log("MOVING CAM")  // Trigger the zooming action
        setHasZoomed(true) // Set the flag to true to prevent future zoom triggers
      }, 2000)  // 2 seconds delay

      return () => clearTimeout(timeout)
    }
  }, [props, hasZoomed])



  const screenPositionRef = useRef(new THREE.Vector3());
const iframePositionRef = useRef(new THREE.Vector3());

  useEffect(() => {




    /*
    if (nodes["Computer"]) {
      // Get the world position of the "Computer" node (the screen part of the model)
      //console.log(screenPosition)
      nodes["Computer"].getWorldPosition(screenPosition)
      screenPositionRef.current.set(screenPosition.x, screenPosition.y, screenPosition.z)
      setScreenPosition(screenPosition) // Update state with screen's world position

      console.log(screenPosition)
      console.log(iframePosition)

     /* iframePositionRef.current.set(
        screenPositionRef.current.x + 17.5,
        screenPositionRef.current.y + 28.1,
        screenPositionRef.current.z - 20
      )


      iframePositionRef.current.set(
        screenPositionRef.current.x + 36,
        screenPositionRef.current.y + 1.225,
        screenPositionRef.current.z - 48.95
      )
      setIframePosition(iframePositionRef.current)


      //setIframePosition(new THREE.Vector3(screenPosition.x + 17.5, screenPosition.y + 28.1, screenPosition.z - 20))

      console.log(screenPositionRef.current)
      console.log(iframePositionRef.current)
    }
  }, [])






  useFrame(({ camera }) => {
    if (props.zooming) {
      console.log("SHOULD BE MOVING CAM")


      const targetPosition = new THREE.Vector3(screenPosition.x + 4, screenPosition.y+1, screenPosition.z - 10)
      const distance = camera.position.distanceTo(targetPosition)

      // Define a threshold distance (e.g., when it's within 1 unit)
      const threshold = 3

      // Only update camera position if it's further than the threshold distance
      if (distance > threshold) {
        // Smoothly interpolate the camera position towards the target position
        camera.position.lerp(targetPosition, 0.007)  // 0.01 controls the smoothness of the movement
      } else {
        // Once we're within the threshold distance, stop moving the camera
        props.setZooming(false)  // Optionally stop zooming if you want to halt movement
        console.log("Camera is close enough, stopping.")

      }

      camera.lookAt(screenPosition);  // Make sure the camera is looking at the screen

    }
  })




  // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
  //rotation-x={-Math.PI / 2}*/

 <group  rotation={[0, Math.PI, 0]} position={[0, 0, 8]}  style={{ width: '80%', height: '80%' }}>
          <Model  style={{ width: '100%', height: '100%' }}   />
        </group>